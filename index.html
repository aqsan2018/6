<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Scratch and Reveal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            /* Disable touch scrolling on the page */
            touch-action: none;
        }

        #game-wrapper {
            width: 100%;
            max-width: 900px;
            padding: 1rem;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        /* Responsive grid for smaller screens */
        @media (min-width: 640px) {
            #game-board {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .card {
            position: relative;
            width: 100%;
            /* Maintain a 1:1 aspect ratio */
            aspect-ratio: 1 / 1;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            background: white; /* White BG for PNGs */
        }

        .card.revealed {
            border: 3px solid #db2777; /* Pink border when revealed */
        }

        .card-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Use contain to see the whole PNG */
            padding: 1rem; /* Padding so image isn't edge-to-edge */
            z-index: 1;
        }

        .scratch-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            cursor: grabbing;
            transition: opacity 0.5s ease-out;
        }

        /* Round complete modal */
        #round-complete-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            /* 'display: flex' and related properties are now handled by Tailwind classes in the HTML */
            backdrop-filter: blur(10px);
        }

        #revealed-images-container {
            display: flex;
            flex-direction: column; /* Vertical on small screens */
            gap: 1rem;
        }

        @media (min-width: 640px) {
            #revealed-images-container {
                flex-direction: row; /* Horizontal on larger screens */
            }
        }

        .revealed-modal-image {
            width: 150px;
            height: 150px;
            border-radius: 0.75rem;
            background: white;
            object-fit: contain;
            padding: 0.5rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            /* Animation */
            opacity: 0;
            transform: translateY(20px);
            animation: slide-in 0.5s ease-out forwards;
        }

        /* Kiss rain animation */
        .kiss-rain {
            position: fixed;
            top: -10vh;
            font-size: 2rem;
            pointer-events: none;
            user-select: none;
            animation: fall 5s linear forwards;
            z-index: 300;
        }

        @keyframes fall {
            0% { transform: translateY(0vh); opacity: 1; }
            100% { transform: translateY(110vh); opacity: 1; }
        }

        @keyframes slide-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

    </style>
</head>
<body class="bg-black">

    <div id="game-wrapper">
        <h1 class="text-3xl font-bold text-center text-pink-400 mb-4">Scratch and reveal</h1>
        <div id="game-board">
            <!-- Cards will be generated by JavaScript -->
        </div>
    </div>

    <!-- 
      FIX: Added Tailwind 'flex' classes here. 
      The 'hidden' class (display: none) will now work correctly 
      to hide the modal on load. When 'hidden' is removed, 
      the 'flex' classes will activate.
    -->
    <div id="round-complete-screen" class="hidden flex flex-col items-center justify-center">
        <div id="revealed-images-container">
            <!-- Revealed images will be added here -->
        </div>
    </div>

    <!-- Audio files -->
    <audio id="scratch-sound" src="scratch_sound.mp3" preload="auto"></audio>
    <audio id="reveal-sound" src="reveal_sound.mp3" preload="auto"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gameBoard = document.getElementById('game-board');
            const roundCompleteScreen = document.getElementById('round-complete-screen');
            const revealedImagesContainer = document.getElementById('revealed-images-container');
            const scratchSound = document.getElementById('scratch-sound');
            const revealSound = document.getElementById('reveal-sound');

            let isDrawing = false;
            let scratchedInRound = 0;
            let revealedImagesInRound = [];
            let rainInterval;
            const cardStates = new Array(12).fill(false); // false = not revealed

            function initGame() {
                for (let i = 1; i <= 12; i++) {
                    const card = document.createElement('div');
                    card.classList.add('card');
                    card.dataset.id = i;

                    const img = document.createElement('img');
                    img.classList.add('card-image');
                    img.src = `${i}.png`; // Your image files
                    img.alt = `Scratch Card ${i}`;
                    // Handle image load errors
                    img.onerror = () => {
                        img.alt = `Error loading ${i}.png`;
                        // You could show a placeholder here
                    };

                    const canvas = document.createElement('canvas');
                    canvas.classList.add('scratch-canvas');
                    
                    card.appendChild(img);
                    card.appendChild(canvas);
                    gameBoard.appendChild(card);

                    // Setup canvas
                    const ctx = canvas.getContext('2d');
                    // We need to set canvas width/height explicitly after it's in the DOM
                    // to get the correct size.
                    setTimeout(() => {
                        canvas.width = canvas.offsetWidth;
                        canvas.height = canvas.offsetHeight;
                        
                        // Draw the silver layer
                        ctx.fillStyle = '#c0c0c0'; // Silver
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Set the "erase" mode
                        ctx.globalCompositeOperation = 'destination-out';
                    }, 0);


                    // --- Event Listeners for scratching ---
                    const startScratch = (e) => {
                        if (cardStates[i-1]) return; // Already revealed
                        isDrawing = true;
                        scratch(e, ctx, canvas);
                    };

                    const endScratch = (e) => {
                        if (cardStates[i-1]) return;
                        isDrawing = false;
                        checkReveal(ctx, canvas, card, img.src);
                    };

                    const scratch = (e, ctx, canvas) => {
                        if (!isDrawing || cardStates[i-1]) return;

                        e.preventDefault(); // Prevent page scrolling

                        // Get coordinates
                        const rect = canvas.getBoundingClientRect();
                        let x, y;
                        if (e.touches) {
                            x = e.touches[0].clientX - rect.left;
                            y = e.touches[0].clientY - rect.top;
                        } else {
                            x = e.clientX - rect.left;
                            y = e.clientY - rect.top;
                        }
                        
                        // Play scratch sound (throttled)
                        if (scratchSound.paused || scratchSound.currentTime > 0.1) {
                            scratchSound.currentTime = 0;
                            scratchSound.play().catch(e => console.log("Audio play prevented"));
                        }

                        // Erase a circle
                        ctx.beginPath();
                        ctx.arc(x, y, 20, 0, Math.PI * 2);
                        ctx.fill();
                    };

                    // Mouse events
                    canvas.addEventListener('mousedown', startScratch);
                    canvas.addEventListener('mousemove', (e) => scratch(e, ctx, canvas));
                    canvas.addEventListener('mouseup', endScratch);
                    canvas.addEventListener('mouseleave', endScratch); // Stop if mouse leaves

                    // Touch events
                    canvas.addEventListener('touchstart', startScratch, { passive: false });
                    canvas.addEventListener('touchmove', (e) => scratch(e, ctx, canvas), { passive: false });
                    canvas.addEventListener('touchend', endScratch);
                }
            }

            function checkReveal(ctx, canvas, card, imgSrc) {
                if (cardStates[card.dataset.id - 1]) return; // Already checked

                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
                const data = imageData.data;
                let transparentPixels = 0;

                // Loop through pixels (checking alpha channel)
                for (let i = 3; i < data.length; i += 4) {
                    if (data[i] === 0) {
                        transparentPixels++;
                    }
                }

                const totalPixels = data.length / 4;
                const scratchedPercentage = (transparentPixels / totalPixels) * 100;

                if (scratchedPercentage > 80) {
                    cardStates[card.dataset.id - 1] = true; // Mark as revealed
                    card.classList.add('revealed');
                    canvas.style.opacity = '0'; // Fade out canvas
                    
                    revealSound.currentTime = 0;
                    revealSound.play().catch(e => console.log("Audio play prevented"));
                    
                    scratchedInRound++;
                    revealedImagesInRound.push(imgSrc);
                    
                    if (scratchedInRound === 3) {
                        showRoundComplete();
                    }
                }
            }

            function showRoundComplete() {
                revealedImagesContainer.innerHTML = ''; // Clear previous images
                
                // Add the 3 revealed images to the modal
                revealedImagesInRound.forEach((src, index) => {
                    const img = document.createElement('img');
                    img.src = src;
                    img.classList.add('revealed-modal-image');
                    // Stagger the animation
                    img.style.animationDelay = `${index * 0.2}s`;
                    revealedImagesContainer.appendChild(img);
                });

                roundCompleteScreen.classList.remove('hidden');
                rainInterval = setInterval(() => createRain('ðŸ’‹'), 200); // Start kiss rain
                
                // Reset for next round
                scratchedInRound = 0;
                revealedImagesInRound = [];

                // Auto-close the modal after 5 seconds
                setTimeout(() => {
                    roundCompleteScreen.classList.add('hidden');
                    if (rainInterval) clearInterval(rainInterval); // Stop the rain
                    // Remove any lingering rain elements
                    document.querySelectorAll('.kiss-rain').forEach(el => el.remove());
                    
                    // Check for game end
                    if (cardStates.every(state => state === true)) {
                        gameBoard.innerHTML = `<h2 class="text-4xl font-bold text-pink-400 text-center col-span-3 sm:col-span-4">All done! You're the best!</h2>`;
                    }
                }, 5000); // 5-second delay
            }

            function createRain(emoji) {
                const rain = document.createElement('div');
                rain.classList.add('kiss-rain');
                rain.textContent = emoji;
                rain.style.left = `${Math.random() * 100}vw`;
                rain.style.animationDuration = `${Math.random()*2 + 3}s`; // 3-5 second fall
                document.body.appendChild(rain);

                setTimeout(() => {
                    rain.remove();
                }, 5000); // Remove after 5 seconds
            }

        initGame();
        });
    </script>
</body>
</html>

