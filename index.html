<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Scratch and Reveal</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÅ</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet"> <!-- Added Orbitron font for lock -->
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            /* overflow: hidden; <-- REMOVED */
            /* Disable touch scrolling on the page */
            touch-action: none;
            background-color: #121212; /* Match black theme */
        }

        /* --- Main Content (Hidden by default) --- */
        #main-content {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.5s ease-in;
            width: 100%;
            display: flex; /* Use flex to easily center content */
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure it takes full viewport height */
            padding: 1rem; /* Add padding for smaller screens */
            box-sizing: border-box;
        }
        #main-content.visible {
             visibility: visible;
             opacity: 1;
        }

        #game-wrapper {
            width: 100%;
            max-width: 900px;
            /* padding: 1rem; <-- Moved padding to main-content */
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        /* Responsive grid for smaller screens */
        @media (min-width: 640px) {
            #game-board {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .card {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            background: white; /* White BG for PNGs */
        }

        .card.revealed {
            border: 3px solid #db2777; /* Pink border when revealed */
        }

        .card-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Use contain to see the whole PNG */
            padding: 1rem; /* Padding so image isn't edge-to-edge */
            z-index: 1;
        }

        .scratch-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            cursor: grabbing;
            transition: opacity 0.5s ease-out;
        }

        /* Round complete modal */
        #round-complete-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            backdrop-filter: blur(10px);
            /* display: flex etc handled by Tailwind */
        }

        #revealed-images-container {
            display: flex;
            flex-direction: column; /* Vertical on small screens */
            gap: 1rem;
        }

        @media (min-width: 640px) {
            #revealed-images-container {
                flex-direction: row; /* Horizontal on larger screens */
            }
        }

        .revealed-modal-image {
            width: 150px;
            height: 150px;
            border-radius: 0.75rem;
            background: white;
            object-fit: contain;
            padding: 0.5rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateY(20px);
            animation: slide-in 0.5s ease-out forwards;
        }

        /* Kiss rain animation */
        .kiss-rain {
            position: fixed;
            top: -10vh;
            font-size: 2rem;
            pointer-events: none;
            user-select: none;
            animation: fall 5s linear forwards;
            z-index: 300;
            color: #ec4899; /* Pink kisses for this theme */
        }

        @keyframes fall {
            0% { transform: translateY(0vh); opacity: 1; }
            100% { transform: translateY(110vh); opacity: 1; }
        }

        @keyframes slide-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* --- Password Lock Styles (Black/Pink Theme) --- */
        #password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.65); /* Black overlay */
            backdrop-filter: blur(8px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500; /* Highest z-index */
            transition: opacity 0.3s ease-out;
        }

        #lock-box {
            background-color: #1f1f1f; /* Dark grey box */
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            text-align: center;
            width: 90%; /* Responsive width */
            max-width: 320px; /* Max width matching black example */
            display: flex; /* Flex to center items inside */
            flex-direction: column;
            align-items: center;
            box-sizing: border-box;
        }

        #lock-gif {
            width: 150px;
            height: 150px;
            border-radius: 0.75rem;
            margin-bottom: 1.5rem;
            margin-left: auto;
            margin-right: auto;
        }

        #password-input {
            font-family: 'Orbitron', sans-serif;
            width: 100%;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            border: 2px solid #4b5563; /* Medium grey border */
            background-color: #374151; /* Darker grey bg */
            color: white; /* White text */
            font-size: 1.1rem;
            text-align: center;
            letter-spacing: 2px;
            box-sizing: border-box;
        }

        #password-input:focus {
            outline: none;
            border-color: #ec4899; /* Pink border on focus */
        }

        #submit-button {
            font-family: 'Orbitron', sans-serif;
            width: 100%;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            background-color: #ec4899; /* Hot pink */
            color: white;
            font-weight: 700;
            margin-top: 1rem;
            transition: background-color 0.2s ease;
            border: none;
            cursor: pointer;
            box-sizing: border-box;
        }

        #submit-button:hover {
            background-color: #db2777; /* Deeper pink */
        }

        #error-message {
            color: #ef4444; /* Red */
            font-size: 0.9rem;
            height: 1.25rem; /* Reserve space */
            margin-top: 0.75rem;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            75% { transform: translateX(8px); }
        }

        .shake {
            animation: shake 0.3s ease-in-out;
        }
        /* --- End Password Lock Styles --- */

    </style>
</head>
<body class="bg-black">

    <!-- --- NEW Password Overlay --- -->
    <div id="password-overlay">
        <form id="lock-box">
            <img id="lock-gif" src="dudu-no-dudu.gif" alt="Dudu Bubu No">
            <input id="password-input" type="password" placeholder="Enter Password">
            <p id="error-message"></p>
            <button id="submit-button" type="submit">Unlock</button>
        </form>
    </div>

    <!-- --- Main Content (Initially Hidden) --- -->
    <div id="main-content">
        <div id="game-wrapper">
            <h1 class="text-3xl font-bold text-center text-pink-400 mb-4">Scratch and reveal</h1>
            <div id="game-board">
                <!-- Cards will be generated by JavaScript -->
            </div>
        </div>
    </div>


    <div id="round-complete-screen" class="hidden flex flex-col items-center justify-center">
        <div id="revealed-images-container">
            <!-- Revealed images will be added here -->
        </div>
        <button id="try-again-button" class="mt-8 bg-pink-600 text-white font-bold py-3 px-6 rounded-full text-lg shadow-lg hover:bg-pink-700 transition-colors">
            Try Again
        </button>
    </div>

    <!-- Audio files -->
    <audio id="scratch-sound" src="scratch_sound.mp3" preload="auto"></audio>
    <audio id="reveal-sound" src="reveal_sound.mp3" preload="auto"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Password Lock Elements ---
            const passwordOverlay = document.getElementById('password-overlay');
            const lockBox = document.getElementById('lock-box');
            const passwordInput = document.getElementById('password-input');
            const errorMessage = document.getElementById('error-message');
            const mainContent = document.getElementById('main-content');
            const correctPassword = "28072018";

            // --- Game Elements (declared here, assigned in initializeGame) ---
            let gameBoard, roundCompleteScreen, revealedImagesContainer, scratchSound, revealSound, tryAgainButton;
            let isDrawing, scratchedInRound, revealedImagesInRound, rainInterval, cardStates;
            let imageNumbers; // Store shuffled image order

            // --- Function to Initialize Game (called after unlock) ---
            function initializeGame() {
                // Assign game elements now
                gameBoard = document.getElementById('game-board');
                roundCompleteScreen = document.getElementById('round-complete-screen');
                revealedImagesContainer = document.getElementById('revealed-images-container');
                scratchSound = document.getElementById('scratch-sound');
                revealSound = document.getElementById('reveal-sound');
                tryAgainButton = document.getElementById('try-again-button');

                isDrawing = false;
                scratchedInRound = 0;
                revealedImagesInRound = [];
                rainInterval = null;
                cardStates = new Array(12).fill(false); // false = not revealed
                imageNumbers = Array.from({length: 12}, (_, i) => i + 1); // Creates [1, 2, ..., 12]

                // --- ADDED SHUFFLE FUNCTION ---
                function shuffleArray(array) {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
                    }
                }

                function initBoard() {
                    gameBoard.innerHTML = ''; // Clear board first
                    shuffleArray(imageNumbers); // Shuffle image order

                    for (let i = 0; i < 12; i++) {
                        const imageNumber = imageNumbers[i];

                        const card = document.createElement('div');
                        card.classList.add('card');
                        card.dataset.id = i;

                        const img = document.createElement('img');
                        img.classList.add('card-image');
                        img.src = `${imageNumber}.png`;
                        img.alt = `Scratch Card ${i}`;
                        img.onerror = () => { img.alt = `Error loading ${imageNumber}.png`; };

                        const canvas = document.createElement('canvas');
                        canvas.classList.add('scratch-canvas');

                        card.appendChild(img);
                        card.appendChild(canvas);
                        gameBoard.appendChild(card);

                        const ctx = canvas.getContext('2d');
                        // Use requestAnimationFrame to ensure layout is done before setting size
                        requestAnimationFrame(() => {
                           if (canvas.offsetWidth > 0 && canvas.offsetHeight > 0) {
                                canvas.width = canvas.offsetWidth;
                                canvas.height = canvas.offsetHeight;
                                ctx.fillStyle = '#c0c0c0'; // Silver
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                ctx.globalCompositeOperation = 'destination-out';
                           }
                        });

                        // --- Event Listeners for scratching ---
                        const startScratch = (e) => {
                            if (cardStates[i]) return;
                            isDrawing = true;
                            scratch(e, ctx, canvas);
                        };

                        const endScratch = (e) => {
                            if (cardStates[i]) return;
                            isDrawing = false;
                            checkReveal(ctx, canvas, card, img.src);
                        };

                        const scratch = (e, ctx, canvas) => {
                            if (!isDrawing || cardStates[i]) return;
                            e.preventDefault();

                            const rect = canvas.getBoundingClientRect();
                            let x, y;
                            if (e.touches) {
                                x = e.touches[0].clientX - rect.left;
                                y = e.touches[0].clientY - rect.top;
                            } else {
                                x = e.clientX - rect.left;
                                y = e.clientY - rect.top;
                            }

                            if (scratchSound.paused || scratchSound.currentTime > 0.1) {
                                scratchSound.currentTime = 0;
                                scratchSound.play().catch(e => console.log("Audio play prevented"));
                            }

                            ctx.beginPath();
                            ctx.arc(x, y, 20, 0, Math.PI * 2);
                            ctx.fill();
                        };

                        // Mouse events
                        canvas.addEventListener('mousedown', startScratch);
                        canvas.addEventListener('mousemove', (e) => scratch(e, ctx, canvas));
                        canvas.addEventListener('mouseup', endScratch);
                        canvas.addEventListener('mouseleave', endScratch);

                        // Touch events
                        canvas.addEventListener('touchstart', startScratch, { passive: false });
                        canvas.addEventListener('touchmove', (e) => scratch(e, ctx, canvas), { passive: false });
                        canvas.addEventListener('touchend', endScratch);
                    }
                }

                function checkReveal(ctx, canvas, card, imgSrc) {
                    if (cardStates[card.dataset.id]) return;

                    const canvasWidth = canvas.width;
                    const canvasHeight = canvas.height;
                    // Check if canvas has valid dimensions
                    if (canvasWidth === 0 || canvasHeight === 0) return;

                    const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
                    const data = imageData.data;
                    let transparentPixels = 0;

                    for (let i = 3; i < data.length; i += 4) {
                        if (data[i] === 0) {
                            transparentPixels++;
                        }
                    }

                    const totalPixels = data.length / 4;
                    const scratchedPercentage = (transparentPixels / totalPixels) * 100;

                    if (scratchedPercentage > 80) {
                        cardStates[card.dataset.id] = true;
                        card.classList.add('revealed');
                        canvas.style.opacity = '0';
                        canvas.style.pointerEvents = 'none'; // Prevent further interaction

                        revealSound.currentTime = 0;
                        revealSound.play().catch(e => console.log("Audio play prevented"));

                        scratchedInRound++;
                        revealedImagesInRound.push(imgSrc);

                        if (scratchedInRound === 3) {
                            showRoundComplete();
                        }
                    }
                }

                function showRoundComplete() {
                    revealedImagesContainer.innerHTML = '';

                    revealedImagesInRound.forEach((src, index) => {
                        const img = document.createElement('img');
                        img.src = src;
                        img.classList.add('revealed-modal-image');
                        img.style.animationDelay = `${index * 0.2}s`;
                        revealedImagesContainer.appendChild(img);
                    });

                    roundCompleteScreen.classList.remove('hidden');
                    if (rainInterval) clearInterval(rainInterval); // Clear old rain
                    document.querySelectorAll('.kiss-rain').forEach(el => el.remove()); // Remove old elements
                    rainInterval = setInterval(() => createRain('üíã'), 200);

                    scratchedInRound = 0;
                    revealedImagesInRound = [];
                }

                 // Moved outside showRoundComplete
                tryAgainButton.addEventListener('click', () => {
                    roundCompleteScreen.classList.add('hidden');
                    if (rainInterval) clearInterval(rainInterval);
                    document.querySelectorAll('.kiss-rain').forEach(el => el.remove());

                    // Check for game end
                    if (cardStates.every(state => state === true)) {
                        gameBoard.innerHTML = `<h2 class="text-4xl font-bold text-pink-400 text-center col-span-3 sm:col-span-4">All done! You're the best!</h2>`;
                    }
                });

                function createRain(emoji) {
                    const rain = document.createElement('div');
                    rain.classList.add('kiss-rain');
                    rain.textContent = emoji;
                    rain.style.left = `${Math.random() * 100}vw`;
                    rain.style.animationDuration = `${Math.random()*2 + 3}s`;
                    document.body.appendChild(rain);

                    setTimeout(() => {
                        rain.remove();
                    }, 5000);
                }

                initBoard(); // Call initBoard to set up the game

            } // --- End of initializeGame function ---


            // --- Password Lock Logic ---
            if (sessionStorage.getItem('isUnlocked') === 'true') {
                passwordOverlay.style.display = 'none';
                mainContent.classList.add('visible'); // Show/fade in
                initializeGame(); // Start game if already unlocked
            }

            lockBox.addEventListener('submit', (e) => {
                e.preventDefault();
                const enteredPassword = passwordInput.value;

                if (enteredPassword === correctPassword) {
                    sessionStorage.setItem('isUnlocked', 'true');
                    passwordOverlay.style.opacity = '0';
                    setTimeout(() => {
                        passwordOverlay.style.display = 'none';
                    }, 300);
                    mainContent.classList.add('visible'); // Show/fade in
                    initializeGame(); // Start game now
                } else {
                    errorMessage.textContent = 'Wrong Password. Try Again!';
                    lockBox.classList.add('shake');
                    passwordInput.value = '';
                    setTimeout(() => {
                        lockBox.classList.remove('shake');
                        errorMessage.textContent = '';
                    }, 1000);
                }
            });

        });
    </script>
</body>
</html>
